---
title: "복잡 명령어 집합의 탄생"
date: 2024-05-20 09:00:00 PM +09:00
categories: [ComputerScience, 컴퓨터구조]
tags: [cs, computer, science, architecture]
---
***

>## <span style='color:#1E90FF'>컴퓨터 구조</span>
컴퓨터 구조를 공부하면서 알게된 내용을 요약해서 작성해보자. <br>

>## <span style='color:#1E90FF'>프로그래머의 눈에 보이는 CPU</span>
- 간단한 프로그램이든 대규모 응용 프로그램이든 간에 컴파일러로 하나하나 간단한 기계 명령어로 변환한다. <br>
- 본빌적으로 CPU 입장에서는 프로그램에 따른 차이가 없다. <br>
- 프로그래머의 눈에 CPU는 매우 단순하다. <br>

>## <span style='color:#1E90FF'>명령어 집합</span>
- CPU도 유형에 따라 고유한 능력 범위를 갖고 있다. <br>
- CPU 능력 범위는 명령어 집합이라고 한다. <br>
- 명령어 집합은 CPU가 할 수 있는 일을 알려준다. <br>
- 서로 다른 형태의 CPU는 다른 유형의 명령어 집합을 갖고 있다. <br>

>## <span style='color:#1E90FF'>추상화: 적을수록 좋다</span>
- 1970년대 프로그램은 어셈블리어로 작성되었기 때문에 일반적으로 명령어 집합이 더욱 풍부해야 하며 명령어 자체 기능도 더 강력해야 한다고 여겼다. <br>
- 명령어 집합이 매우 적거나 명령어 기능 자체가 단순했다면 프로그램 만들기 어려웠을 것이다. <br>
- 이것이 이 시기 컴퓨터 과학자들이 말하는 의미상 간격을 이어 주는 것에 해당한다. <br>
- 당시에는 함수 호출, 순환 제어, 복잡한 주소 지정 패턴, 데이터 구조, 배열 접근 등 고급 언어의 개념과 이에 직접 대응하는 기계 명령어가 있어야 한다고 생각했다. 기계 명령어와 고급 언어 개념 간 차이를 줄여야만 더 적은 코드로 더 많은 작업을 할 수 있었기 때문이다. <br>

>## <span style='color:#1E90FF'>코드도 저장 공간을 차지한다</span>
- 오늘날의 컴퓨터는 기본적으로 폰 노이만 구조를 따른다. <br>
- 이 구조의 핵심 사상은 저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떤 차이도 없어야 하며, 모두 컴퓨터의 저장 장치 안에 저장될 수 있어야 한다는 것이다. <br>
- 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 저장 공간을 차지한다는 것을 알 수 있다. <br>
- 작은 메모리에 더 많은 프로그램을 적재하려면 기계 명령어를 반드시 매우 세밀하게 설계해서 프로그램이 차지하는 저장 공간을 줄여야 한다. <br>
- 이에 다음 요구 사항을 만족해야 한다.
    - 하나의 기계 명령어로 더 많은 작업을 완료할 수 있어 더 효율적으로 코드 작성이 가능하다.
    - 기계 명령어 길이가 가변적이라 프로그램 자체가 차지하는 저장 공간을 줄일 수 있다.
    - 기계 명령어는 밀도를 높여 공간을 절약하려고 고도로 인코딩 된다.

>## <span style='color:#1E90FF'>복잡 명령어 집합의 탄생</span>
- 명령어를 사용한 편리한 프로그램을 작성하고 코드의 저장 공간을 절약해야 했기에 복잡 명령어 집합이 탄생했고 당시 산업계의 요구 사항을 충분히 만족시켰다. <br>
- 이 시기 CPU 명령어 집합은 모두 직접 연결 방식이었다. 즉, 명령어 인출(IF), 명령어 해독(ID), 실행(EX) 등 각 단계가 특정 조합 회로로 직접 제어했다. 명령어 실행에는 매우 효율적이지만, 유연성이 몹시 떨어져 명령어 집합의 변경에 대응하기가 어려웠다. <br>
- 하드웨어를 변경하는 것은 매우 번거롭지만, 소프트웨어는 이와 다르게 쉽게 변경할 수 있다. <br>
- 대부분의 명령어에 포함된 연산을 더 간단한 명령어로 구성된 작은 프로그램으로 정의하고 CPU에 저장하면, 모든 기계 명령어에 대응하여 전용 하드웨어 회로를 설계할 필요가 없다. <br>
- 소프트웨어가 하드웨어를 대체한다. 여기에 사용되는 더 간단한 명령어가 마이크로코드다. <br>
- 더 많은 명령어를 추가할 때, 주요 작업은 마이크로코드 수정에 집중되며 하드웨어 수정은 거의 필요하지 않기에 CPU 설계 복잡도를 낮출 수 있다. <br>

>## <span style='color:#1E90FF'>마이크로코드 설계의 문제점</span>
- 마이크로코드의 버그를 수정하는 것은 일반 프로그램의 버그를 수정하는 것보다 훨씬 더 어려울 뿐만 아니라, 트랜지스터를 매우 많이 소모한다. <br>